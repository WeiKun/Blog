# 基于共享内存的资源共享方案设计(正在实现与完善中)
基本上每一个Online游戏都有一堆填表数据，这部分数据特点是只读、进程间一致，如果有方案能让这部分数据不仅数据上一致，而且背后的内存持久化结构也一致，同时还在内存空间中连续存储，就可以采用共享内存或者KSM等方式让进程间共享这部分内存，从而降低内存占用。

为了表达方便，我将最终展现在内存中的数据结构中的元素分为两类：
- 一类是资源数据，就是实际用到的数据；
- 一类是辅助数据，用于组织资源数据，例如如果一个array，需要用一个辅助的长度变量来表达其长度

## 现有数据组织方案
从数据结构格式上说，现在有两个流行的处理方案：
### 特化struct方案
一种是每一类数据用一个不同的struct来表达，由于每一层的数据都是基础类型(int/float/string+array+struct)，因此数据的组织情况在编译器就可以确定，并且由于是直接展开的，所以基本不存在隐含数据(可能只有array的长度需要)，显然是地址无关的，所以可以保证所有进程都一致。

但是这种方案实际上很多问题：
- 不能良好的处理稀疏数据，每一个struct需要的空间是固定的，不会因为某些实例的某些变量不存在而减少，这样就会非常浪费空间。
- array并不能良好地根据某key进行hash寻址，往往在加载进内存之后还要新建hashtable进行辅助处理，这部分不仅是浪费，而且由于缺乏通用hash算法(因为key数据结构都不通用，hash算法自然也不能通用)，还要浪费时间去做每一个的hash算法，而算法往往还要随着数据规模的改变而修改。
- 缺乏反射机制，没有反射的数据结构操作起来灵活性会大大降低
- 由于数据结构是特化的，因此缺乏通用操作(例如迭代操作)，所以往往表达力不够，同时由于表达力的不够，往往需要定义继承自数据结构的新类来封装一些操作接口，这样就让数据共享很难做，并且意义也不大(不能共享的部分太大，并且跟共享的交叉在一起，想解耦合需要成本)。

### 通用数据类型方案
另一种是用通用的数据类型来表达数据，典型就是lua/python之类的脚本语言，用key可以自由组织的table来替代array跟struct。

这样做的表达力很强，而且由于是稀疏存储的通用类型，所以实际上如何糟糕的容器方案都不会导致太大的浪费（对比特化struct）。

但是由于是通用的数据类型，很可能容器里存储的仅仅是数据的指针，这部分是地址相关的，而且由于是通用数据，往往有可能需要在数据里留有指针指向相应的type结构体地址，这部分进程间也是很难保持一致的。
## 设想的解决方案

1. 首先肯定要保证数据的表达力，因此还是需要仿python的数据组织方式。

2. 然后，考虑到每一份res的数据总集合是收敛的，因此可以将所有数据都pack到一块连续内存上，把相互之间的地址索引修改为相对地址偏移量。这样就可以保证这部分的地址无关。

3. 最后解决指向type结构体的指针，这个指针是为了对外暴露使用方式(例如执行a.update()就会通过type结构体，顺着规则找到update方法)，如果我的所有数据结构都并不暴露给外部直接使用，那么就不需要保留这个指针，而只需要提供类型枚举来保证内部操作的准确性。

关于3的具体的使用方式举例，现在有一个实际存储数据的dict类型ResDict，它的key/value只有ResInt跟ResString以及ResDict类型，其实例为resdict，我们用一个ResDictImp类型来封装对这个数据操作：
- 对于has操作，自定义ResDictImp的has_key方法，由于操作是内聚的，不需要赘述
- 对于get操作，如果get到的类型是ResInt或者ResString，直接重新在虚拟机里用值new一个真实的PyString或者PyInt返回，如果是ResDict，那么返回一个ResDictImp的实例，在实例里指向ResDict
- 对于iterxxx操作，跟get类似，每一个拿到的都是PyString/PyInt/ResDictImp

这样就保证没有直接对Res类型的访问，所有访问都被ResXXXImp代理或者直接拿到就是普通的py数据类型。

这样做的好处就是能在保持灵活性的基础上达到数据严格一致，从而使内存共享可行，另外还能保证数据的只读性（因为没有写的接口）。坏处就是很多操作的时间性能会降低，例如读取int/string时或者执行迭代时会复制数据，退化成keys/values/items。

## 设计方案
从经验上说，能完整的表达资源数据，需要实现int/long/string/float/dict/tuple(/set)这6(7)种数据类型即可。最原始的功能集合甚至可以只有int/str/dict三个。其中每一个容器类型还需要提供一个Imp类型，来

### Res数据类型
先只考虑最简单功能集合。
#### ResInt
需要实现__hash__/__cmp__/__equ__功能，以及提供转换为PyInt的接口，前者是为了能在容器里进行操作(例如dict里的查询、tuple里判断是否存在等)，后者是为了返回给调用者。

#### ResStr
同ResInt一样，需要实现__hash__/__cmp__/__equ__功能，以及提供转换为PyString的接口

#### ResDict
需要实现get/has_key的功能和封装成ResDictImp的接口(其中get的返回需要通过上面的转换接口转为py类型或者ResDictImp)

### Imp数据类型
#### ResDictImp
需要封装ResDict的get/has_key，还要提供迭代操作接口，iteritems/iterkeys/itervalues，当然对于ResDictImp来说，这几个跟items/keys/values是一样的

## 适用性
首先方案是可以适用于python的。但是实际上也完全可以适用于C/C++甚至其他语言，只需要针对需求修改下Imp操作的执行方式，下面以dict的get如果要迁移到C/C++来举例：
1. 对C/C++传入的接口参数根据需求进行约束，例如可以只允许int/string/vector<int>/vector<int>四种类型
2. 对于传出的数据，在get函数里分配空间，然后由调用方负责释放，跟python不一样的是，需要实现一下相应的string/float/int/long(不能直接用C的float/int/long，因为这样需要在get时预设本次get到的值是什么类型，灵活性会降低)